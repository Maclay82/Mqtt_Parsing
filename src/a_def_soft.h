#ifndef A_DEF_SOFT_H
#define A_DEF_SOFT_H
// your code

// Определения программных констант и переменных (параметры эффектов и т.п.)

// При запуске микроконтроллера выполняется инициализация всех параметров значениями, сохраненными в EEPROM (функция loadSettings() в eeprom.ino)
// При этом если флаг EEPROM_OK в первой строке файла eeprom.ino был изменен и не совпадает со считанными яз ячейки #0 значением -
// выполняется инициализация параметров значениями по умолчанию (функция loadSettings() в eeprom.ino, ветвь if (isInitialized) -> false )
// Заполните в этом блоки значения переменных желаемыми.

#define EEPROM_OK     0xA7       // Флаг, показывающий, что EEPROM инициализирована корректными данными 
#define EEPROM_MAX    4096       // Максимальный размер EEPROM доступный для использования
#define EFFECT_EEPROM  300       // начальная ячейка eeprom с параметрами эффектов, 5 байт на эффект
#define TEXT_EEPROM    800       // начальная ячейка eeprom с текстом бегущих строк

#define BRIGHTNESS      32       // стандартная максимальная яркость (0-255)

// ******************* ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ ЭФФЕКТОВ *********************

// Список и порядок эффектов, передаваемый в приложение на смартфоне. Данный список попадает в комбобокс выбора, 
// чей индекс передается из приложения в контроллер матрицы для выбора, поэтому порядок должен соответствовать 
// списку эффектов, определенному выше

#define EFFECT_LIST F("Часы,Лампа,Снегопад,Кубик,Радуга,Пейнтбол,Огонь,The Matrix,Шарики,Звездопад,Конфетти," \
                      "Цветной шум,Облака,Лава,Плазма,Радужные переливы,Полосатые переливы,Зебра,Шумящий лес,Морской прибой,Смена цвета," \
                      "Светлячки,Водоворот,Циклон,Мерцание,Северное сияние,Тени,Лабиринт,Змейка,Тетрис,Арканоид," \
                      "Палитра,Спектрум,Синусы,Вышиванка,Дождь,Камин,Водопад,Стрелки,Анимация,Погода,Жизнь,Узоры,Рассвет")

// Ниже представлен список эффектов, поддерживаемых прошивкой. Нумерация - сплошная от ID = 0 до ID = MAX_EFFECT
// Если какие-то эффекты вам не нужны - перенесите их в конец списка, исправьте нумерацию и поправьте MAX_EFFECT так,
// чтобы ненужные эффекты имели номера бОльшие MAX_EFFECT.
// Так как перебор эффектов идет от 0 до MAX_EFFECT-1, эффекты с номерами за этим диапазоном не будут отображаться.
// Также требуется исправить список эффектов EFFECT_LIST (см.выше) так, чтобы названия и порядок эффектов
// соответствовал списку, определенному ниже. Отключенные эффекты не должны писутствовать в EFFECT_LIST

// ID эффектов
#define MC_CLOCK                 0         // Режим отображения часов (когда "Ночные часы" или просто "Часы" на черном фоне, а не как оверлей поверх других эффектов
#define MC_DAWN_ALARM           43


#define MAX_EFFECT              44         // количество эффектов, определенных в прошивке
// ---------------------------------

// *************************************************************************

enum  eModes   {NORMAL, COLOR, TEXT};
//eModes parseMode; // Текущий режим парсера
enum  eSources {NONE, BOTH, UDP, MQTT};
//eSources cmdSource; // Источник команды; NONE - нет значения; BOTH - любой, UDP-клиент, MQTT-клиент

// ****************** ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ БУДИЛЬНИКА ********************


// ********************* ОПРЕДЕЛЕНИЯ ПАРАМЕТРОВ ЧАСОВ **********************


//int8_t  hrs = 0, mins = 0;                  // Для получения текущего времени. Инициализировано как 01.01.1970 00:00
//int8_t  secs = 0, aday = 1, amnth = 1;
//int16_t ayear = 1970;

// ************************ НАСТРОЙКИ БЕГУЩЕЙ СТРОКИ ***********************

//uint16_t crc = 0;                           // Контрольная сумма загруженного массива строк. Рассчитывается при загрузке, проверяется перед сохранением 
int16_t  memoryAvail = 0;                   // Сколько памяти осталось под хранение строк; Устанавливается при загрузке / сохранении массива строк


String  textLines[36];                      // Массив строк для отображения 0..9A..Z; 


// *************************** ПОДКЛЮЧЕНИЕ К СЕТИ **************************

// Внимание!!! Если вы меняете эти значения ПОСЛЕ того, как прошивка уже хотя бы раз была загружена в плату и выполнялась,
// чтобы изменения вступили в силу нужно также изменить значение константы EEPROM_OK в первой строке в файле eeprom.ino 

#define DEFAULT_NTP_SERVER "ru.pool.ntp.org" // NTP сервер по умолчанию "time.nist.gov"
#define DEFAULT_AP_NAME "PanelAP"           // Имя точки доступа по умолчанию 
#define DEFAULT_AP_PASS "12341111"          // Пароль точки доступа по умолчанию

#ifndef NETWORK_SSID
#define NETWORK_SSID ""                     // Имя WiFi сети
#endif

#ifndef NETWORK_PASS
#define NETWORK_PASS ""                     // Пароль для подключения к WiFi сети
#endif

#ifndef DEFAULT_IP
#define DEFAULT_IP {192, 168, 0, 100}       // Сетевой адрес устройства по умолчанию
#endif

// ---------------------------------------------------------------

WiFiUDP udp;                                // Объект транспорта сетевых пакетов
                                            // к длине +1 байт на \0 - терминальный символ. Это буферы для загрузки имен/пароля из EEPROM. Значения задаются в define выше
char   apName[11] = DEFAULT_AP_NAME;        // Имя сети в режиме точки доступа
char   apPass[17] = DEFAULT_AP_PASS;        // Пароль подключения к точке доступа
char   ssid[25]   = NETWORK_SSID;           // SSID (имя) вашего роутера (конфигурируется подключением через точку доступа и сохранением в EEPROM)
char   pass[17]   = NETWORK_PASS;           // пароль роутера
byte   IP_STA[]   = DEFAULT_IP;             // Статический адрес в локальной сети WiFi по умолчанию при первом запуске. Потом - загружается из настроек, сохраненных в EEPROM
unsigned int localPort = 2390;              // локальный порт на котором слушаются входящие команды управления от приложения на смартфоне, передаваемые через локальную сеть

// ------------------------ MQTT parameters --------------------
#if (USE_MQTT == 1)

WiFiClient m_client;                            // Объект для работы с удалёнными хостами - соединение с MQTT-сервером
PubSubClient mqtt(m_client);                    // Объект соединения с MQTT сервером

// Внимание!!! Если вы меняете эти значения ПОСЛЕ того, как прошивка уже хотя бы раз была загружена в плату и выполнялась,
// чтобы изменения вступили в силу нужно также изменить значение константы EEPROM_OK в строке 8 этого файла

#ifndef DEFAULT_MQTT_SERVER
#define DEFAULT_MQTT_SERVER "srv1.clusterfly.ru" // MQTT сервер
#endif

#ifndef DEFAULT_MQTT_USER
#define DEFAULT_MQTT_USER   "user_af7cd12a"      // Имя mqtt-пользователя    (укажите имя пользователя для вашего соединения)
#endif

#ifndef DEFAULT_MQTT_PASS
#define DEFAULT_MQTT_PASS   "pass_eb250bf5"      // Пароль mqtt-пользователя (укажите пароль вашего соединения)
#endif

#ifndef DEFAULT_MQTT_PORT
#define DEFAULT_MQTT_PORT   9124                 // Порт mqtt-соединения
#endif

#ifndef DEFAULT_MQTT_PREFIX
#define DEFAULT_MQTT_PREFIX "user_af7cd12a"      // Префикс топика сообщения или пустая строка, если префикс не требуется
#endif

#ifndef MQTT_SEND_DELAY                          // Отправлять сообщение на MQTT-сервер не чаще 1 сообщения в секунду (ограничение бесплатного MQTT сервера);
#define MQTT_SEND_DELAY     0                    // Сообщения, отправленные чаще защитного интервала "съедаются" сервером (игнорируются, пропадают); 
#endif                                           // Если нет ограничений на частоту отправки сообщений - поставьте здесь 0
                                                  

// Код работы с MQTT-каналом ориентирован на использование MQTT-брокера mqtt.4api.ru
// Для управления и отладки можно использовать одну из следующих консолей: client.mqtt.4api.ru, hivemq.com/demos/websocket-client

#define  TOPIC_CMD      "cmd"                    // Топик - получение команды управления от клиента
#define  TOPIC_DTA      "dta"                    // Топик - отправка запрошенных данных клиенту
#define  TOPIC_ERR      "err"                    // Топик - отправка уведомлений об ошибке клиенту
#define  TOPIC_STA      "sta"                    // Топик - отправка уведомления о (ре)старте микроконтроллера
#define  TOPIC_ALM      "alm"                    // Топик - отправка клиенту сообщений о событиях будильника
#define  TOPIC_AMD      "amd"                    // Топик - отправка клиенту сообщений о событиях авторежимов по времени
#define  TOPIC_WTR      "wtr"                    // Топик - отправка клиенту сообщений о событиях погоды
#define  TOPIC_TME      "tme"                    // Топик - отправка клиенту сообщений о событиях времени
#define  TOPIC_PWR      "pwr"                    // Топик - отправка клиенту сообщений о включении/выключении устройства
#define  TOPIC_SDC      "sdc"                    // Топик - отправка клиенту сообщений о событиях SD-карты
#define  TOPIC_TXT      "txt"                    // Топик - отправка клиенту сообщений о событиях бегущей строки
#define  TOPIC_STT      "stt"                    // Топик - отправка клиенту сообщений о текущем статусе параметров устройства - основной набор параеметров (пакет)

bool     useMQTT = true;                         // Использовать канал управления через MQTT - флаг намерения    // При отключении из приложения set_useMQTT(false) устанавлифается соответствующее состояние (параметр QA), состояние 'намерение отключить MQTT'
bool     stopMQTT = false;                       // Использовать канал управления через MQTT - флаг результата   // которое должно быть отправлено на MQTT-сервер, значит реально состояние 'MQTT остановлен' - только после отправки флага QA на сервер
char     mqtt_server[25] = "";                   // Имя сервера MQTT
char     mqtt_user[15]   = "";                   // Логин от сервера
char     mqtt_pass[15]   = "";                   // Пароль от сервера
char     mqtt_prefix[31] = "";                   // Префикс топика сообщения
uint16_t mqtt_port       = DEFAULT_MQTT_PORT;    // Порт для подключения к серверу MQTT
uint16_t mqtt_send_delay = MQTT_SEND_DELAY;      // Задержка между последовательными обращениями к MQTT серверу
bool     mqtt_state_packet = true;               // Способ передачи состояния: true - в пакете, false - каждый параметр индивидуально

// Выделение места под массив команд, поступающих от MQTT-сервера
// Callback на поступление команды от MQTT сервера происходит асинхронно, и если предыдущая
// команда еще не обработалась - происходит новый вызов обработчика команд, который не реентерабелен -
// это приводит к краху приложения. Чтобы избежать этого поступающие команды будем складывать в очередь 
// и выполнять их в основном цикле программы
#define  QSIZE_IN 8                         // размер очереди команд от MQTT
#define  QSIZE_OUT 96                       // размер очереди исходящих сообщений MQTT
String   cmdQueue[QSIZE_IN];                // Кольцевой буфер очереди полученных команд от MQTT
String   tpcQueue[QSIZE_OUT];               // Кольцевой буфер очереди отправки команд в MQTT (topic)
String   outQueue[QSIZE_OUT];               // Кольцевой буфер очереди отправки команд в MQTT (message)
bool     rtnQueue[QSIZE_OUT];               // Кольцевой буфер очереди отправки команд в MQTT (retain)
byte     queueWriteIdx = 0;                 // позиция записи в очередь обработки полученных команд
byte     queueReadIdx = 0;                  // позиция чтения из очереди обработки полученных команд
byte     queueLength = 0;                   // количество команд в очереди обработки полученных команд
byte     outQueueWriteIdx = 0;              // позиция записи в очередь отправки MQTT сообщений
byte     outQueueReadIdx = 0;               // позиция чтения из очереди отправки MQTT сообщений
byte     outQueueLength = 0;                // количество команд в очереди отправки MQTT сообщений

String   last_mqtt_server = "";
uint16_t last_mqtt_port = 0;

String   changed_keys = "";                 // Строка, содержащая список измененных параметров, чье состояние требуется отправить серверу
bool     mqtt_connecting = false;           // Выполняется подключение к MQTT (еще не установлено)
bool     mqtt_topic_subscribed = false;     // Подписка на топик команд выполнена
byte     mqtt_conn_cnt = 0;                 // Счетчик попыток подключения для форматирования вывода
unsigned long mqtt_conn_last;               // Время последней попытки подключения к MQTT-серверу
unsigned long mqtt_send_last;               // Время последней отправки сообщения к MQTT-серверу
uint16_t upTimeSendInterval = 0;            // Интервал отправки uptime в секундах, 0 если не нужно отправлять
unsigned long uptime_send_last;             // Время последней отправки uptime к MQTT-серверу по инициативе устройства
#endif

// ---------------------------------------------------------------

bool   useSoftAP = false;                   // использовать режим точки доступа
bool   wifi_connected = false;              // true - подключение к wifi сети выполнена  
bool   ap_connected = false;                // true - работаем в режиме точки доступа;

// **************** СИНХРОНИЗАЦИЯ ЧАСОВ ЧЕРЕЗ ИНТЕРНЕТ *******************

IPAddress timeServerIP;
#define NTP_PACKET_SIZE 48                  // NTP время - в первых 48 байтах сообщения
uint16_t SYNC_TIME_PERIOD = 60;             // Период синхронизации в минутах по умолчанию
byte packetBuffer[NTP_PACKET_SIZE];         // буфер для хранения входящих и исходящих пакетов NTP

int8_t timeZoneOffset = 7;                  // смещение часового пояса от UTC
long   ntp_t = 0;                           // Время, прошедшее с запроса данных с NTP-сервера (таймаут)
byte   ntp_cnt = 0;                         // Счетчик попыток получить данные от сервера
bool   init_time = false;                   // Флаг false - время не инициализировано; true - время инициализировано
bool   refresh_time = true;                 // Флаг true - пришло время выполнить синхронизацию часов с сервером NTP
bool   useNtp = true;                       // Использовать синхронизацию времени с NTP-сервером
bool   getNtpInProgress = false;            // Запрос времени с NTP сервера в процессе выполнения
char   ntpServerName[31] = "";              // Используемый сервер NTP


// *********************** ДЛЯ БУДИЛЬНИКА-РАССВЕТ ************************

bool   isAlarming = false;                  // Сработал будильник "рассвет"
bool   isAlarmStopped = false;              // Сработавший будильник "рассвет" остановлен пользователем

byte   alarmWeekDay = 0;                    // Битовая маска дней недели будильника
byte   alarmDuration = 1;                   // Проигрывать звук будильнике N минут после срабатывания (по окончанию рассвета)

byte   alarmHour[7]   = {0,0,0,0,0,0,0};    // Часы времени срабатывания будильника по дням недели
byte   alarmMinute[7] = {0,0,0,0,0,0,0};    // Минуты времени срабатывания будильника по дням недели

int8_t dawnHour = 0;                        // Часы времени начала рассвета
int8_t dawnMinute = 0;                      // Минуты времени начала рассвета
byte   dawnWeekDay = 0;                     // День недели времени начала рассвета (0 - выключено, 1..7 - пн..вс)
byte   dawnDuration = 10;                   // Продолжительность "рассвета" по настройкам в минутах
byte   realDawnDuration = 0;                // Продолжительность "рассвета" по вычисленному времени срабатывания будильника
byte   alarmEffect = MC_DAWN_ALARM;         // Какой эффект используется для будильника "рассвет". Могут быть обычные эффекты - их яркость просто будет постепенно увеличиваться

// ************************* КНОПКА УПРАВЛЕНИЯ *************************

#if (BUTTON_TYPE == 0)
  GButton butt(PIN_BTN, LOW_PULL, NORM_OPEN);    // Для сенсорной кнопки
#else
  GButton butt(PIN_BTN, HIGH_PULL, NORM_OPEN);   // Для обычной кнопки
#endif

bool     isButtonHold = false;              // Кнопка нажата и удерживается
byte     bCounter = 0;                      // Счетчик нажатия на кнопку

// ******************** ВКЛЮЧЕНИЕ РЕЖИМОВ ПО ВРЕМЕНИ *********************

bool     AM1_running = false;               // Режим 1 по времени - работает
byte     AM1_hour = 0;                      // Режим 1 по времени - часы
byte     AM1_minute = 0;                    // Режим 1 по времени - минуты
int8_t   AM1_effect_id = -3;                // Режим 1 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM2_running = false;               // Режим 2 по времени - работает
byte     AM2_hour = 0;                      // Режим 2 по времени - часы
byte     AM2_minute = 0;                    // Режим 2 по времени - минуты
int8_t   AM2_effect_id = -3;                // Режим 2 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM3_running = false;               // Режим 3 по времени - работает
byte     AM3_hour = 0;                      // Режим 3 по времени - часы
byte     AM3_minute = 0;                    // Режим 3 по времени - минуты
int8_t   AM3_effect_id = -3;                // Режим 3 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     AM4_running = false;               // Режим 4 по времени - работает
byte     AM4_hour = 0;                      // Режим 4 по времени - часы
byte     AM4_minute = 0;                    // Режим 4 по времени - минуты
int8_t   AM4_effect_id = -3;                // Режим 4 по времени - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     dawn_running = false;              // Режим по времени "Рассвет" - работает
byte     dawn_hour = 0;                     // Режим по времени "Рассвет" - часы
int8_t   dawn_effect_id = -3;               // Режим по времени "Рассвет" - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST
bool     dusk_running = false;              // Режим по времени "Закат" - работает
byte     dusk_hour = 0;                     // Режим по времени "Закат" - часы
byte     dusk_minute = 0;                   // Режим по времени "Закат" - минуты
int8_t   dusk_effect_id = -3;               // Режим по времени "Закат" - ID эффекта или -3 - выключено (не используется); -2 - выключить матрицу (черный экран); -1 - ночные часы, 0 - случайный, 1 и далее - эффект EFFECT_LIST

// ************************* ПРОЧИЕ ПЕРЕМЕННЫЕ *************************


// ---------------------------------------------------------------

#define  AUTOPLAY_PERIOD      60            // время между авто сменой режимов (секунды)
#define  IDLE_TIME            30            // время бездействия (в минутах, по умолчанию) после которого запускается автосмена режимов, если разрешена в настройках
#define  SMOOTH_CHANGE         0            // плавная смена режимов через чёрный

// ---------------------------------------------------------------

bool     eepromModified = false;            // флаг: EEPROM изменен, требует сохранения

// ---------------------------------------------------------------

bool     isTurnedOff = false;               // Включен черный экран (т.е всё выключено) 

// ---------------------------------------------------------------

// Сервер не может инициировать отправку сообщения клиенту - только в ответ на запрос клиента
// Следующие две переменные хранят сообщения, формируемые по инициативе сервера и отправляются в ответ на ближайший запрос от клиента,
// например в ответ на периодический ping - в команде sendAcknowledge();

String   cmd95 = "";                        // Строка, формируемая sendPageParams(95) для отправки по инициативе сервера
String   cmd96 = "";                        // Строка, формируемая sendPageParams(96) для отправки по инициативе сервера

// ---------------------------------------------------------------

byte     globalBrightness = BRIGHTNESS;     // текущая яркость бегущей строки и часов (общая)
byte     contrast = 255;                    // контрастность эффектов по отношению к яркости часов / бегущей строки (общей яркости) => 0.255 -> 10..100%
bool     brightDirection = false;           // true - увеличение яркости; false - уменьшение яркости при регулировке кнопкой

// ---------------------------------------------------------------

bool     manualMode = false;                // флаг: true - ручное управление эффектами; false - в режиме Autoplay

// ---------------------------------------------------------------

uint32_t idleTime = ((long)IDLE_TIME * 60 * 1000L);     // минуты -> миллисек
uint32_t autoplayTime = ((long)AUTOPLAY_PERIOD * 1000L);// секунды -> миллисек
bool     idleState = true;                              // флаг холостого режима работы
uint32_t autoplayTimer;                                 // время до автоматического перехода в демо-режим
uint32_t upTime = 0;                                    // время работы системы с последней перезагрузки

// ---------------------------------------------------------------

int8_t   thisMode = 0;                      // текущий режим - id
String   effect_name = "";                  // текущий режим - название

// ---------------------------------------------------------------
timerMinim idleTimer(idleTime);             // Таймер бездействия ручного управления для автоперехода в демо-режим 

timerMinim saveSettingsTimer(15000);        // Таймер отложенного сохранения настроек
timerMinim ntpSyncTimer(1000 * 60 * SYNC_TIME_PERIOD);    // Сверяем время с NTP-сервером через SYNC_TIME_PERIOD минут

// ********************* ДЛЯ ПАРСЕРА КОМАНДНЫХ ПАКЕТОВ *************************

#define    BUF_MAX_SIZE  4096               // максимальный размер выделяемого буфера для коммуникации по UDP каналу
#define    PARSE_AMOUNT  16                 // максимальное количество значений в массиве, который хотим получить
#define    header '$'                       // стартовый символ управляющей посылки
#define    divider ' '                      // разделительный символ
#define    ending ';'                       // завершающий символ
 
int32_t    intData[PARSE_AMOUNT];           // массив численных значений после парсинга - для WiFi часы время синхр м.б отрицательным + 
                                            // период синхронизации м.б больше 255 мин - нужен тип int32_t
char       incomeBuffer[BUF_MAX_SIZE];      // Буфер для приема строки команды из wifi udp сокета; также используется для загрузки строк из EEPROM
char       replyBuffer[8];                  // ответ клиенту - подтверждения получения команды: "ack;/r/n/0"

byte       ackCounter = 0;                  // счетчик отправляемых ответов для создания уникальности номера ответа

#if (USE_MQTT == 1)
#define    BUF_MQTT_SIZE  384               // максимальный размер выделяемого буфера для входящих сообщений по MQTT каналу
char       incomeMqttBuffer[BUF_MQTT_SIZE]; // Буфер для приема строки команды из MQTT
#endif

// --------------- ВРЕМЕННЫЕ ПЕРЕМЕННЫЕ ПАРСЕРА ------------------

boolean    recievedFlag;                               // буфер содержит принятые данные
boolean    parseStarted;
byte       parse_index;
String     string_convert = "";
String     receiveText = "";
bool       haveIncomeData = false;
char       incomingByte;

int16_t    bufIdx = 0;                                 // Могут приниматься пакеты > 255 байт - тип int16_t
int16_t    packetSize = 0;

// ************************* УПРАВЛЕНИЕ МАТРИЦЕЙ *******************************
String     host_name = "";                       // Имя для регистрации в сети, а так же как имя клиента та сервере MQTT

#define    TRUE_RANDOM

// *****************************************************************************
// *****************************************************************************
// *****************************************************************************
// *****************************************************************************
// *****************************************************************************

// ------------------- ФАЙЛОВАЯ СИСТЕМА SPIFFS ----------------------

bool       spiffs_ok = false;                    // Флаг - файловая система SPIFFS доступна для использования
size_t     spiffs_total_bytes;                   // Доступно байт в SPIFFS
size_t     spiffs_used_bytes;                    // Использовано байт в SPIFFS
int8_t     eeprom_backup = 0;                    // Флаг - backup настроек 0 - нeт; 1 - FS; 2 - SD; 3 - FS и SD

// ------------------- ВРЕМЕННЫЕ ПЕРЕМЕННЫЕ ----------------------

byte       saveMode;
byte       tmpSaveMode = 0;

// ---------------------------------------------------------------
#endif
